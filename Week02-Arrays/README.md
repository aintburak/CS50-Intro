# Lecture 2 - CS50x 2024

## Compilation Process in C Programming

This document outlines the compilation process in C programming, explaining the concepts of preprocessing, compiling, assembling, and linking.

## 1. Preprocessing

Preprocessing is the initial stage of the compilation process. It involves handling directives written in the source code that start with a `#` symbol. These directives, such as `#include`, `#define`, and conditional compilation directives (`#ifdef`, `#ifndef`, `#endif`), are processed by the preprocessor. Its primary role is to manipulate the source code before actual compilation starts.



## 2. Compiling

Compiling translates human-readable source code (e.g., C or C++) into machine-readable instructions called object code. The compiler parses the entire source code, checks for syntax errors, and translates it into an intermediate form known as assembly language. The output of the compiler is one or more object files (`.o` files), each containing machine code for a specific source file.


#### Object Files (.o)

In compiling, a .o file is an object file generated by the compiler. When you compile a program written in a language like C or C++, the source code is first translated into machine code or assembly language. However, rather than creating a single large file containing all the machine code for the entire program, the compiler typically breaks the translation process into smaller units, with each unit corresponding to a source file.

For each source file, the compiler generates an object file (usually with a .o extension). This object file contains the translated machine code or assembly code for that specific source file. It also includes metadata and symbols that allow the linker to later combine multiple object files into a single executable or shared library.

Object files serve as intermediates in the compilation process. They represent the translation of individual source files into machine code or assembly code, but they are not yet directly executable by the operating system. Instead, they need to be linked together with other object files and libraries to create a final executable or shared library.


Recall that last week you learned about a compiler, a specialized computer program that converts source code into machine code that can be understood by a computer.

For example, you might have a computer program that looks like this:

```c
#include <stdio.h>

int main(void)
{
    printf("hello, world\n");
}
```

A compiler will take the above code and turn it into the following machine code:


```
01111111 01010101 01001110 01000110 00000010 00000001 00000000 00000000
01111101 00000001 01111110 00000001 00000001 00000001 00000001 00000001
10110100 00000001 01010100 00000001 00000001 00000001 00000001 00000001
11010100 00000001 00000000 00000001 00000001 00000001 00000001 00000001
01101110 00000001 01000110 00000001 00000001 00000001 00000001 00000001
01111110 00000001 00000000 00000001 00000001 00000001 00000001 00000001
01101111 00000001 01001000 00000001 00000001 00000001 00000001 00000001
01101000 00000001 01000001 00000001 00000001 00000001 00000001 00000001
01111110 00000001 01000100 00000001 00000001 00000001 00000001 00000001
01101111 00000001 01001110 00000001 00000001 00000001 00000001 00000001
01111000 00000001 01001000 00000001 00000001 00000001 00000001 00000001
01111000 00000001 01000000 00000001 00000001 00000001 00000001 00000001
01101110 00000001 01001110 00000001 00000001 00000001 00000001 00000001
01111000 00000001 01001000 00000001 00000001 00000001 00000001 00000001
01111000 00000001 00000000 00000001 00000001 00000001 00000001 00000001
01111000 00000001 00000000 00000001 00000001 00000001 00000001 00000001
...
```


In VS Code, the programming environment provided to you as a CS50 student, utilizes a compiler called clang or c language, so if you were to type `make hello`, it runs a command that executes **clang** to create an output file that you can run as a user.

VS Code has been pre-programmed such that `make` will run numerous command line arguments along with clang for your convenience as a user.

Let's have a look the following code:
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string name = get_string("What's your name? ");
    printf("hello, %s\n", name);
}
```

You can attempt to enter into the terminal window: `clang -o hello hello.c`. You will be met by an error that indicates that clang does not know where to find the cs50.h library.
Attempting again to compile this code, run the following command in the terminal window: `clang -o hello hello.c -lcs50`. This will enable the compiler to access the cs50.h library. 

> Please note that in this case you may have different class name such as credit.c, that time, you should change `clang -o credit credit.c -lcs50`. If you do not include any additional libraries, it would be enough to exevute  `clang -o credit credit.c`.


Running in the terminal window `./hello`, your program will run as intended. While the it is offered as an illustration, such that you can understand more deeply the process and concept of compiling code, using make in CS50 is perfectly fine and the expectation!





Compiling comprises several significant stages, among which preprocessing stands out. This initial step involves the inclusion of header files in your code, marked by # directives (e.g., `#include <cs50.h>`), which essentially involves copying and integrating the content of these files into your source file. For instance, during preprocessing, the content of `cs50.h` gets integrated into your program. Likewise, when your code includes `#include <stdio.h>`, the content of `stdio.h` located somewhere on your system is brought into your program. This process can be depicted as follows:

```c
string get_string(string prompt);
int printf(string format, ...);

int main(void)
{
    string name = get_string("What's your name? ");
    printf("hello, %s\n", name);
}
```

Next, compiling is where your program is converted into assembly code. This step can be visualized as follows:

```assembly
...
main:
    # @main
    .cfi_startproc
# BB#0:
    pushq   %rbp
.Ltmp0:
    .cfi_def_cfa_offset 16
.Ltmp1:
    .cfi_offset %rbp, -16
    movq    %rsp, %rbp
.Ltmp2:
    .cfi_def_cfa_register %rbp
    subq    $16, %rsp
    xorl    %eax, %eax
    movl    %eax, %edi
    movabsq $.L.str, %rsi
    movb    $0, %al
    callq   get_string
    movabsq $.L.str1, %rdi
    movq    %rax, -8(%rbp)
    movq    -8(%rbp), %rsi
    movb    $0, %al
    callq   printf
    ...
```


Next, assembling has resulted in the compiler converting the assembly code you've made into machine code. This step can be visualized as follows:


Assembly

```
mov eax, 5     ; Move the number 5 into the EAX register
mov ebx, 10    ; Move the number 10 into the EBX register
add eax, ebx   ; Add the value in EBX to the value in EAX (EAX = EAX + EBX)
```

Corresponding Machine Code:


```
B8 05 00 00 00    ; Opcode for 'mov eax, 5' where B8 is the mov instruction for EAX and '05 00 00 00' is the little-endian representation of 5
BB 0A 00 00 00    ; Opcode for 'mov ebx, 10' where BB is the mov instruction for EBX and '0A 00 00 00' is the little-endian representation of 10
01 D8             ; Opcode for 'add eax, ebx' where 01 is the add instruction and D8 is the encoding for using EBX as the source and EAX as the destination
```

This is an oversimplified example and actual machine code can be more complex. Also, it's worth noting that the machine code will look different based on the processor's instruction set architecture (ISA). The above is an example for an x86 ISA.















## 3. Assembling

Assembling converts assembly language code into machine code. Assembly language is a low-level programming language more readable for humans than machine code but less abstract than high-level languages like C. The assembler takes the assembly code produced by the compiler and converts it into machine code, typically represented in binary form.

## 4. Linking

Linking combines multiple object files and libraries into a single executable or shared library. When compiling programs with multiple source files or using external libraries, the compiler generates separate object files for each source file. The linker resolves references between these object files and libraries, such as function calls, to create a single executable file runnable by the operating system.


## Components

#### Linker:

* The `linker` is a program that combines various object files and libraries into a single executable or shared library. It resolves references between different parts of the program and ensures that all necessary components are present for the program to execute properly.

#### Compiler:

* A `compiler` is a program that translates source code written in a high-level programming language into machine code or another intermediate form. It performs various tasks such as syntax checking, optimization, and code generation.

#### Assembler:

* An `assembler` is a program that translates assembly language code into machine code. Assembly language is a low-level programming language that is more human-readable than machine code but less abstract than high-level languages like C. Assemblers are used primarily in low-level programming for tasks like device driver development and system programming.

#### Preprocessor and its components:

* The `preprocessor` is a stage in the compilation process that handles directives written in the source code. Its components include directives such as #include for including header files, #define for defining macros, #ifdef, #ifndef, #endif for conditional compilation, among others. These directives are processed before the actual compilation begins and can affect how the source code is interpreted by the compiler.


---


## **Arrays and Memory Usage in C Programming**

### Overview
In the first week of our course, we explored basic data types including boolean, integer, character, string, and more. Here's a breakdown of the memory each data type consumes:
- Boolean (`bool`): 1 byte
- Integer (`int`): 4 bytes
- Long integer (`long`): 8 bytes
- Floating point (`float`): 4 bytes
- Double precision floating point (`double`): 8 bytes
- Character (`char`): 1 byte
- String (`string`): variable size

Given the limited memory inside a computer, understanding how data is allocated and managed is crucial.

### Data Representation in Memory
Visualizing how data is stored can be helpful:
- A `char` occupies 1 byte.
- An `int` occupies 4 bytes.

### Programming Example
To put these concepts into practice, you can write a simple C program to compute the average of three scores. Open your terminal and create a file named `scores.c` with the following code:

```c
#include <stdio.h>

int main(void) {
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;

    printf("Average: %f
", (score1 + score2 + score3) / 3.0);
}
```
This program demonstrates the use of floating point division to obtain a decimal result. After compiling and running this program, you can visualize how variables are stored in memory.

### Using Arrays for Storage
Arrays provide a method to store sequential data efficiently in memory. For instance, declaring `int scores[3]` instructs the compiler to allocate memory for three consecutive integers. Here is how you can modify your program to use arrays:

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    int scores[3];
    for (int i = 0; i < 3; i++) {
        scores[i] = get_int("Score: ");
    }

    printf("Average: %f
", (scores[0] + scores[1] + scores[2]) / 3.0);
}
```
By using a loop to index through the array, this approach simplifies data management and retrieval.

### Refactoring for Better Abstraction
To further enhance the program, abstract the average calculation into a separate function. This makes the program cleaner and the functionality reusable:

```c
#include <cs50.h>
#include <stdio.h>

const int N = 3;
float average(int length, int array[]);

int main(void) {
    int scores[N];
    for (int i = 0; i < N; i++) {
        scores[i] = get_int("Score: ");
    }

    printf("Average: %f
", average(N, scores));
}

float average(int length, int array[]) {
    int sum = 0;
    for (int i = 0; i < length; i++) {
        sum += array[i];
    }
    return sum / (float) length;
}
```
This refactor not only cleans up the main function but also demonstrates how arrays can be effectively passed between functions in C.

---

## Strings Overview
In C programming, a string is essentially an array of characters (`char`), terminated by a NUL character (`\0`).

### Visual Representation of Strings
Imagine a string as an array that begins with the first character and ends with a special NUL character that signifies the end of the string. For example, the string "HI!" would be stored as follows:

- 'H'
- 'I'
- '!'
- '\0' (NUL character)

### Implementing Strings in Code
To use strings in your code, you might start by creating a file named `hi.c` and input the following code to print each character:

```c
#include <stdio.h>

int main(void) {
    char c1 = 'H';
    char c2 = 'I';
    char c3 = '!';

    printf("%c%c%c\n", c1, c2, c3);
}
```
This outputs the characters as a string.

To display the ASCII values instead, modify the code like this:

```c
#include <stdio.h>

int main(void) {
    char c1 = 'H';
    char c2 = 'I';
    char c3 = '!';

    printf("%i %i %i\n", c1, c2, c3);
}
```

### Further Exploration with `cs50.h` Library
Using the `cs50.h` library, you can handle strings more efficiently. For instance, revising the code to use the `string` type would look like:

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string s = "HI!";
    printf("%c%c%c\n", s[0], s[1], s[2]);
}
```
This example prints the ASCII values of the characters including the NUL terminator:

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string s = "HI!";
    printf("%i %i %i %i\n", s[0], s[1], s[2], s[3]);
}
```

### Handling Multiple Strings
To handle multiple strings, you might create an array of strings:

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string words[2];

    words[0] = "HI!";
    words[1] = "BYE!";

    printf("%s\n", words[0]);
    printf("%s\n", words[1]);
}
```

### Determining String Length
Finding the length of a string is a common task in C. Hereâ€™s how you can implement it:

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string name = get_string("Name: ");
    int n = 0;
    while (name[n] != '\0') {
        n++;
    }
    printf("%i\n", n);
}
```
A more refined approach uses a separate function to abstract the counting process:

```c
#include <cs50.h>
#include <stdio.h>

int string_length(string s);

int main(void) {
    string name = get_string("Name: ");
    int length = string_length(name);
    printf("%i\n", length);
}

int string_length(string s) {
    int n = 0;
    while (s[n] != '\0') {
        n++;
    }
    return n;
}
```
To utilize the `string.h` library for finding string length, you can simply use the `strlen` function:

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void) {
    string name = get_string("Name: ");
    int length = strlen(name);
    printf("%i\n", length);
}
```

### Utilizing Command-Line Arguments
Command-line arguments are a way to pass information to a program at startup. Here is an example of a simple greeting program that utilizes command-line arguments:

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[]) {
    if (argc == 2) {
        printf("hello, %s\n", argv[1]);
    } else {
        printf("hello, world\n");
    }
}
```
--- 

## Exit Status Explanation

In computer programming, an exit status, or exit code, is a small number returned by a program to the system upon the termination of the program. This exit code provides an indication of whether the program terminated successfully or encountered an error.

### Standard Exit Codes
- **`Exit Status 0:`** This indicates that the program executed successfully without any errors.

- **`Exit Status 1:`** This is often used to indicate that the program encountered an error which caused it to exit prematurely.

### Example: Command-Line Arguments Check
Consider the following example where a program checks for the correct number of command-line arguments before proceeding:

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc != 2)
    {
        printf("Missing command-line argument\n");
        return 1; // Exit status 1 indicates an error due to missing argument
    }
    printf("hello, %s\n", argv[1]);
    return 0; // Exit status 0 indicates success
}
````
Notice that if you ***fail*** to provide `./status David`, you will get an exit status of **`1`**. However, if you do provide `./status David`, you will get an exit status of **`0`**.

You can imagine how you might use portions of the above program to check if a user provided the correct number of command-line arguments.


## To Sum Up


In this readme, you learned more details about compiling and how data is stored within a computer. 

1. Generally, how a compiler works.
2. How to debug your code using four methods.
3. How to utilize arrays within your code.
3. How arrays store data in back to back portions of memory.
4. How strings are simply arrays of characters.
5. How to interact with arrays in your code.
6. How command-line arguments can be passed to your programs.

